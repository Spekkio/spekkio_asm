; It's not possible to design a OPcodes with mixed-in 
; arguments, like this bbbbaabbaaaa0101, they need to
; be in a line -> bbbbbbaaaaaa0101.

; x = dont care
; a-z,A-Z (except x) = argument
; a-z!=A-Z

-OPTIONS
WORD_LEN=STATIC     ; Words are x bit static, OP Codes they cannot vary in size, RISC type machine.
WORD_SIZE=16        ; 16bit OPcodes
WORDS_RAM=0x10000   ; Number of Words in RAM 

;BITS_RAM=0x100000 
;BYTES_RAM=0x20000  ; 128kByte RAM

;Intruction name:ARG1,ARG2,..:OPCODE(bits)
-INSTRUCTIONS
NOP:   :xxxxxxxxxxx00000:   ; 
JSR:a  :aaaaaa0000010000:   ; - pushes the address of the next instruction to the stack, then sets PC to 'a'
SET:a,b:bbbbbbaaaaaa0001:   ; - sets a to b
ADD:a,b:bbbbbbaaaaaa0010:   ; - sets a to a+b, sets O to 0x0001 if there's an overflow, 0x0 otherwise
SUB:a,b:bbbbbbaaaaaa0011:   ; - sets a to a-b, sets O to 0xffff if there's an underflow, 0x0 otherwise
MUL:a,b:bbbbbbaaaaaa0100:   ; - sets a to a*b, sets O to ((a*b)>>16)&0xffff
DIV:a,b:bbbbbbaaaaaa0101:   ; - sets a to a/b, sets O to ((a<<16)/b)&0xffff. if b==0, sets a and O to 0 instead.
MOD:a,b:bbbbbbaaaaaa0110:   ; - sets a to a%b. if b==0, sets a to 0 instead.
SHL:a,b:bbbbbbaaaaaa0111:   ; - sets a to a<<b, sets O to ((a<<b)>>16)&0xffff
SHR:a,b:bbbbbbaaaaaa1000:   ; - sets a to a>>b, sets O to ((a<<16)>>b)&0xffff
AND:a,b:bbbbbbaaaaaa1001:   ; - sets a to a&b
BOR:a,b:bbbbbbaaaaaa1010:   ; - sets a to a|b
XOR:a,b:bbbbbbaaaaaa1011:   ; - sets a to a^b
IFE:a,b:bbbbbbaaaaaa1100:   ; - performs next instruction only if a==b
IFN:a,b:bbbbbbaaaaaa1101:   ; - performs next instruction only if a!=b
IFG:a,b:bbbbbbaaaaaa1110:   ; - performs next instruction only if a>b
IFB:a,b:bbbbbbaaaaaa1111:   ; - performs next instruction only if (a&b)!=0

;INT:n :nnnnnn0000100000:   ; - Sends an interrupt with number 'n'
;CLI:  :xxxxxx0000110000:   ; - Clears the interrupt flag
;STI:  :xxxxxx0001000000:   ; - Sets the interrupt flag
;LCR:a :aaaaaa0001010000:   ; - Loads the CR into 'a'
;SCR:a :aaaaaa0001100000:   ; - Stores the value of 'a' into CR
;An argument can contain the values 0-9 and x.

;Argument name:SUBARG1,SUBARG2,...:BIT Pattern:Next Word:Used for what instr:
-ARGUMENTS
A          :   :000000::All:
B          :   :000001::All:
C          :   :000010::All:
X          :   :000011::All:
Y          :   :000100::All:
Z          :   :000101::All:
I          :   :000110::All:
J          :   :000111::All:
Ra         :a  :001aaa::All:
[n+a]      :n,a:010aaa:nnnnnnnnnnnnnnnn:All: ; [next word + register]
POP        :   :011000::All: ; [SP++]
PEEK       :   :011001::All: ; [SP]
PUSH       :   :011010::All: ; [--SP]
SP         :   :011011::All:
PC         :   :011100::All:
O          :   :011101::All:
[n]        :   :011110:nnnnnnnnnnnnnnnn:All: ; [next word]
n          :n  :011111:nnnnnnnnnnnnnnnn:All: ; next word
v          :v  :1vvvvv::All:                 ; Literal value


; a found variable, can be represented with regexp
; [\\ ]*[0-9x]\\{1,1000\\}[\\ ]*

; any other character, here plus is the character.
; +\\{1\\}

; If a number is defined, it's either any of the two
; arguments in the bottom. probably it's v if the value is >0x20
; use the const_mask value to know.

; Some of these, like the register names are just symbols
; with values. So they can get put into the symbols struct.

;Values: (6 bits)
;    0x00-0x07: register (A, B, C, X, Y, Z, I or J, in that order)
;    0x08-0x0f: [register]
;    0x10-0x17: [next word + register]
;         0x18: POP / [SP++]
;         0x19: PEEK / [SP]
;         0x1a: PUSH / [--SP]
;         0x1b: SP
;         0x1c: PC
;         0x1d: O
;         0x1e: [next word]
;         0x1f: next word (literal)
;    0x20-0x3f: literal value 0x00-0x1f (literal)
